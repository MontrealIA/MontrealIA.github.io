{"pages":[{"title":"Montréal Artificial Intelligence","text":"AVIS LÉGAL - LEGAL NOTICE​ ​​Publication Information [Executive Order: HQ III M[5-X]] :​​​​​​​​Approval Authority : Vincent Boucher, Founding Chairman and Secretary-General at Montréal.AI.​​​​Office of Primary Responsibility : The Canada Strategic Information Analysis Council Inc. THIS IS A MONTREAL.AI SOFTWARE / SYSTEM. MATERIALS PROVIDED IN THIS SOFTWARE / SYSTEM ARE PROVIDED WITHOUT WARRANTY OF ANY KIND AND DOES NOT CONSTITUTE ENDORSEMENT. THIS SOFTWARE / SYSTEM IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL MONTREAL.AI, THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THIS SOFTWARE / SYSTEM OR THE USE OR OTHER DEALINGS IN THIS SOFTWARE / SYSTEM. EVIDENCE OF UNAUTHORIZED USE MAY BE PROVIDED TO APPROPRIATE PERSONNEL FOR ADMINISTRATIVE, CRIMINAL OR OTHER LEGAL ACTION.​​​​​​​✉️ Email Us : info@montreal.ai​🌐 Website : http://www.montreal.ai/​​#AI #AIFirst #MontrealAI #MontrealArtificialIntelligence","link":"/MontrealAI.github.io/about/index.html"},{"title":"Montréal Artificial Intelligence","text":"Montréal.AI Academy : AI 101AI 101 : The Dawn of Artificial Intelligence The First Comprehensive Overview of AI for the General PublicAI 101 : A Well-Crafted Actionable 75 Minutes Tutorial POWERFUL &amp; USEFUL. This actionable tutorial is designed to entrust everybody with the mindset, the skills and the tools to see artificial intelligence from an empowering new vantage point by : — Exalting state of the art discoveries and science ;— Curating the best open-source codes &amp; implementations ; and— Embodying the impetus that drives today’s artificial intelligence. Montréal.AI is the largest artificial intelligence community in Canada. Join us and learn at https://www.facebook.com/groups/MontrealAI/ ! #AI4Artists : Unveilling a World of Hidden SecretsPioneering Legendary Creations “The Artists Creating with AI Won’t Follow Trends; THEY WILL SET THEM.“ — Vincent Boucher, B. Sc. Theoretical Physics, M. A. Government Policy Analysis and M. Sc. Aerospace Engineering and Founding Chairman of Montréal.AI Designed for artists, #AI4Artists is created to inspire artists who, with AI, will shape the 21st Century. See the Pen Robot Neil’s Bubble Bath by Tero Parviainen (@teropa) on CodePen. ＊ This 75 minutes tutorial is presently in alpha, with a limited number of customers to help us refine it. As we enter beta, we’ll take on many more groups (minimum 150 persons) from the waiting list. ✉️ Group Reservation : academy@montreal.ai🌐 Website : http://www.academy.montreal.ai/ #AI #AIFirst #MontrealAI #MontrealAIAcademy #MontrealArtificialIntelligence","link":"/MontrealAI.github.io/academy/index.html"},{"title":"Montréal Artificial Intelligence","text":"WebAI — Artificial Intelligence for the WebDeploying machine learning in the browser unlocks new possibilities, like interactive artificial intelligence! On a mobile device, the algorithm can even leverage sensor data (i.e.: gyroscope or accelerometer). Further, all data stays on the client, making TensorFlow.js useful for privacy preserving applications. Three workflows with TensorFlow.js : Existing, pre-trained model can be imported for inference ; Imported model can re-trained quickly (transfer learning) with only a small amount of data ; and Models can be directly authored (define, train, and run) in the browser. There’s no need to install any libraries or drivers. Just open a webpage, and your program is ready to run. How Can I Order an AI Agent ? const MathUtils = { lerp(a, b, t) { return a + t * (b - a); }, }; class Agent { constructor( brain = new NeuralNetwork( null, new NeuralNetworkLayer(2), new NeuralNetworkLayer(2), new NeuralNetworkLayer(1) ), ) { this.boundingBox = new Rectangle(); this.brain = brain; this.isAlive = true; this.position = new Vector2(); this.score = 0; } dispose() { this.brain.dispose(); } kill() { this.isAlive = false; } render(context) { context.save(); context.globalCompositeOperation = 'darken'; context.fillStyle = this.isAlive ? '#ea2d2d' : '#dde1e4'; context.fillRect( this.boundingBox.left, this.boundingBox.top, this.boundingBox.width, this.boundingBox.height); context.restore(); } update(context, target) { const { width } = context.canvas; const sizeHalf = 0.5 * Agent.SIZE; const output = this.brain.predict([this.position.x, target]) .dataSync(); this.position.x += Agent.SPEED * output[0]; this.position.x = Math.max(sizeHalf, Math.min(width - sizeHalf, this.position.x)); this.updateBoundingBox(); } updateBoundingBox() { const sizeHalf = 0.5 * Agent.SIZE; this.boundingBox.left = this.position.x - sizeHalf; this.boundingBox.right = this.position.x + sizeHalf; this.boundingBox.top = this.position.y - sizeHalf; this.boundingBox.bottom = this.position.y + sizeHalf; } static get SIZE() { return 8; } static get SPEED() { return 64; } static fromParents(a, b) { return new Agent(NeuralNetwork.fromParents(a.brain, b.brain)); } } class NeuralNetwork { constructor(weights, ...layers) { this.inputLayerSize = layers[0].size; this.layers = layers; this.weights = weights || layers .slice(0, layers.length - 1) .map((layer, index) => { const layerSizeNext = layers[index + 1].size; return tf.randomUniform([layer.size, layerSizeNext], -1, 1); }); } dispose() { this.weights .forEach(w => w.dispose()); } getWeights() { return this.weights .map(weights => weights.dataSync()); } predict(input) { return tf.tidy(() => { const inputLayer = tf.tensor(input, [1, this.inputLayerSize]); return this.weights.reduce((layer, weights, index) => { const fn = this.layers[index].fn; const result = layer.matMul(weights); return result[fn]() .sub(tf.scalar(0.5)); }, inputLayer); }); } static get MUTATION_PROBABILITY() { return 0.05; } static fromParents(a, b) { const weightsA = a.getWeights(); const weightsB = b.getWeights(); const weightsC = new Float32Array(weightsA.length).fill() .map(_ => Math.random() * 2 - 1); const weights = new Array(weightsA.length).fill() .map((_, index) => { const a = weightsA[index]; const b = weightsB[index]; return new Float32Array(a.length).fill() .map((_, weightIndex) => { if (Math.random() < NeuralNetwork.MUTATION_PROBABILITY) { return Math.random() * 2 - 1; } return Math.random() < 0.5 ? a[weightIndex] : b[weightIndex]; }); }) .map((arr, index) => tf.tensor(arr, a.weights[index].shape)); return new NeuralNetwork(weights, ...a.layers); } } class NeuralNetworkLayer { constructor(size, fn = 'sigmoid') { this.fn = fn; this.size = size; } } class Obstacle { constructor(gapSize) { this.gapSize = gapSize; this.gapSizeHalf = 0.5 * gapSize; this.position = new Vector2(); } render(context) { const { width } = context.canvas; context.save(); context.beginPath(); context.moveTo(0, this.position.y); context.lineTo(this.position.x - this.gapSizeHalf, this.position.y); context.moveTo(this.position.x + this.gapSizeHalf, this.position.y); context.lineTo(width, this.position.y); context.lineWidth = Agent.SIZE; context.strokeStyle = '#444f56'; context.stroke(); context.restore(); } overlaps(context, rectangle) { const { width } = context.canvas; const a = new Rectangle( new Vector2(0, this.position.y), new Vector2(this.position.x - this.gapSizeHalf, this.position.y), ); const b = new Rectangle( new Vector2(this.position.x + this.gapSizeHalf, this.position.y), new Vector2(width, this.position.y), ); return ( Rectangle.overlap(rectangle, a) || Rectangle.overlap(rectangle, b) ); } } class Population { constructor(size) { this.agents = new Array(size).fill().map(_ => new Agent()); this.generation = 0; this.size = size; } get isAlive() { return this.agents.some(a => a.isAlive); } dispose() { this.agents.forEach(a => a.dispose()); } next() { const agents = this.agents; const parents = this.agents .sort((a, b) => b.score < a.score ? -1 : 1) .slice(0, 2); this.agents = this.agents.map(() => Agent.fromParents(...parents)); agents.forEach(a => a.dispose()); ++this.generation; } setAgentPosition(position) { this.agents.forEach((agent) => { agent.position.copy(position); agent.updateBoundingBox(); }); } } class Rectangle { constructor(v1 = new Vector2, v2 = new Vector2) { this._left = Math.min(v1.x, v2.x); this._right = Math.max(v1.x, v2.x); this._top = Math.min(v1.y, v2.y); this._bottom = Math.max(v1.y, v2.y); this.updateSize(); } get bottom() { return this._bottom; } set bottom(value) { this._bottom = value; this.updateSize(); } get left() { return this._left; } set left(value) { this._left = value; this.updateSize(); } get right() { return this._right; } set right(value) { this._right = value; this.updateSize(); } get top() { return this._top; } set top(value) { this._top = value; this.updateSize(); } updateSize() { this.height = this._bottom - this._top; this.width = this._right - this._left; } static overlap(a, b) { if ( a.left > b.right || b.left > a.right || a.bottom < b.top || b.bottom < a.top ) return false; return true; } } class Vector2 { constructor(x = 0, y = 0) { this.x = x; this.y = y; } addScalar(s) { this.x += s; this.y += s; return this; } clone() { return new Vector2(this.x, this.y); } copy(v) { this.x = v.x; this.y = v.y; return this; } subtractScalar(s) { this.x -= s; this.y -= s; return this; } } const animate = (fn) => { let frame = 0; const reset = () => (frame = 0); const update = (time) => { requestAnimationFrame(update); fn(time, frame++, reset); }; update(performance.now()); }; const context = document.getElementById('canvas').getContext('2d'); context.canvas.height = 512; context.canvas.width = 512; const elementParamAgentsAlive = document.getElementById('param-agents-alive'); const elementParamGeneration = document.getElementById('param-generation'); const elementParamHighscore = document.getElementById('param-highscore'); let highscore = 0; const agentPositionOriginal = new Vector2( 0.5 * context.canvas.width, context.canvas.height - 2 * Agent.SIZE ); const obstacle = new Obstacle(8 * Agent.SIZE); obstacle.position.x = context.canvas.width * Math.random(); let isUnloaded = false; const population = new Population(8); population.setAgentPosition(agentPositionOriginal); animate((time, frame, reset) => { if (isUnloaded) return; if (!population.isAlive) { population.next(); population.setAgentPosition(agentPositionOriginal); reset(); return; } const { height, width } = context.canvas; const obstacleFrameLoop = (frame % 120) / 120; context.clearRect(0, 0, width, height); if (obstacleFrameLoop === 0) { obstacle.position.x = MathUtils.lerp( 2 * Agent.SIZE, width - 2 * Agent.SIZE, Math.random() ); } obstacle.position.y = height * obstacleFrameLoop; obstacle.render(context); population.agents.forEach((agent) => { if (agent.isAlive) { agent.update(context, obstacle.position.x); agent.score += (512 - Math.abs(agent.position.x - obstacle.position.x)) / 512; } if (obstacle.overlaps(context, agent.boundingBox)) { agent.kill(); } agent.render(context); }); highscore = Math.max(highscore, population.agents.reduce((highscore, a) => Math.max(highscore, a.score), 0)); elementParamAgentsAlive.textContent = population.agents.filter(a => a.isAlive).length; elementParamGeneration.textContent = population.generation; elementParamHighscore.textContent = highscore.toFixed(2); }); window.addEventListener('beforeunload', () => { population.dispose(); isUnloaded = true; }); Neuro-evolution Witness agents (depicted red) learn to pass the gaps in the walls. Generation 0 Highscore 0 Agents (alive) 0 Generate a population of agents with random neural networks The population of agents spawn Agents try to move through the gaps After all agents are dead (depicted grey), pick out the top two Generate a new population by cross-breeding the top two, with a small probability of mutation Go to step 2 #AI #AIFirst #MontrealAI #MontrealArtificialIntelligence","link":"/MontrealAI.github.io/web-ai/index.html"},{"title":"Montréal Artificial Intelligence","text":"Montréal.AI’s Chief AI Officers : Powerful Economic Drivers World-Class Deep Learning ExpertsTo succeed in many of its endeavors and to be ready for tomorrow, Montréal.AI relies on recruiting, developing and training completion-oriented men and women with the determination to ensure a fully Joint Workforce : Intellectually, operationally, organizationally, doctrinally, and technically. “ We want to see more widespread matrix interoperability, individual and life-long learning opportunities and development of connoisseurs, high-profile and ultra-affluent Chief AI Officers who possess the knowledges, the skills and the competencies to orchestrate impactful breakthroughs and tangible economic growth for Fortune 500, governments and interagency partners in full compliance with our masterplan : The Montréal AI-First Conglomerate Overarching Program.“ Since top AI talent is extremely scarce right now and consulting the right AI leader can dramatically increases your odds of business success, Montréal.AI specifically develops professional Chief AI Officers dedicated to effectively take advantage of AI and to synergically fulfill its responsibilities with flexibility and responsiveness. ✉️ Email Us : info@chiefaiofficers.com Montréal.AI Atelier : Top AI ModelsThe Montréal.AI Atelier creates and deploys scorching AI deep learning top AI models in the browser from transfer learning combined with reinforcement learning (RL) and good old fashioned machine learning intuition. Montréal.AI’s Chief AI Officers design and deploy top AI models that are faster and generalize better. AI Consultation ServicesConsidering that hiring in AI is very competitive since you’re battling for the best talent with Google, Facebook, Microsoft, etc., our in-house Chief AI Officers are offering consultation services to develop tailored artificial intelligence algorithms and more. Montréal.AI relishes the opportunity to cooperate. References : ‘Million-dollar babies‘ - http://www.economist.com/news/business/21695908-silicon-valley-fights-talent-universities-struggle-hold-their ‘The Battle for Top AI Talent Only Gets Tougher From Here‘ - https://www.wired.com/2017/03/intel-just-jumped-fierce-competition-ai-talent/ ‘A.I. Researchers Are Making More Than $1 Million, Even at a Nonprofit‘ - https://www.nytimes.com/2018/04/19/technology/artificial-intelligence-salaries-openai.html “Last year, the cost of a top, world-class deep learning expert was about the same as a top NFL quarterback prospect. The cost of that talent is pretty remarkable.” — Peter Lee, chef de la recherche chez Microsoft ✉️ Email Us : info@montreal.ai🌐 Website : http://www.montreal.ai/ #AI #AIFirst #ChiefAIOfficers #MontrealAI #MontrealArtificialIntelligence","link":"/MontrealAI.github.io/chiefaiofficers/index.html"},{"title":"Montréal Artificial Intelligence","text":"AVIS LÉGAL - LEGAL NOTICE​​MATERIALS PROVIDED IN THIS SYSTEM ARE PROVIDED WITHOUT WARRANTY OF ANY KIND AND DOES NOT CONSTITUTE ENDORSEMENT. | LES INFORMATIONS DONNÉES PAR CE SYSTÈME SONT FOURNIES SANS GARANTIE D’AUCUNE SORTE ET NE CONSTITUENT PAS UNE APPROBATION.​​✉️ Email Us : info@montreal.ai​🌐 Website : http://www.montreal.ai/​​#AI #AIFirst #MontrealAI #MontrealArtificialIntelligence","link":"/MontrealAI.github.io/about/index copy.html"},{"title":"WebAI — Artificial Intelligence for the Web","text":"Deploying AI in the BrowserRunning machine learning programs entirely client-side in the browser unlocks new opportunities, like interactive ML! From a user’s perspective, there’s no need to install any libraries or drivers : Just open a webpage, and your program is ready to run! On a mobile device, the model can take advantage of sensor data (i.e.: gyroscope or accelerometer). Finally, all data stays on the client, making TensorFlow.js useful for low-latency inference, as well as for privacy preserving applications. Low-Latency Inference and Privacy Preserving Applications The … See the Pen Robot Neil’s Bubble Bath by Tero Parviainen (@teropa) on CodePen. #AI #AIFirst #MontrealAI #MontrealArtificialIntelligence","link":"/MontrealAI.github.io/web-ai/index 2.html"}],"posts":[{"title":"Montréal Artificial Intelligence","text":"Montréal AI-First Conglomerate : A Win-Win Approach Montréal.AI Joint Transformative AI Engineering Task ForceThe Montréal.AI’s Joint Transformative AI Engineering Task Force, operating unilaterally or in combination with multinational and interagency partners, is accountable for the pre-eminent deployment and orchestration of the Montréal AI-First Conglomerate Overarching Program. 🌐 http://montreal.ai/taskforce.pdf SOLVING Humanity’s Toughest ChallengesMontréal Artificial Intelligence adopts a new tradition of responsibility to create win-win situations. By focusing on the others players we develop cooperative opportunities within the wider perspective of society. “Successful business strategy is about actively shaping the game you play, not just playing the game you find“ — The Right Game: Use Game Theory to Shape Strategy | A. Brandenburger &amp; B. Nalebuff Under Montreal.AI’s umbrella, multiple companies and organisation are being structured. Montréal.AI (EST’B’D 2003)As the foundational architecture of Montréal.AI’s operations, the strategic concept of decisive excellence governs our efforts to enable previously impossible tasks to be accomplished by designing, developing and implementing interoperable AI processes and systems to ensure full spectrum pre-eminent deployment. ❖ Montréal.AI WebTraining and deploying artificial intelligence and ML models in the browser ❖ Chief AI Officers‘Hiring the right #AI leader can dramatically increases your odds of success.‘ - Andrew Ng ❖ Montréal.AI AcademyTraining the individuals who, with AI, will shape the 21st Century. ✉️ Email Us : info@montreal.ai🌐 Website : http://www.montreal.ai/ #AI #AIFirst #MontrealAI #MontrealArtificialIntelligence","link":"/MontrealAI.github.io/2018/06/27/index/"}],"tags":[],"categories":[]}